### SLOGO Design.MD

The purpose of this project is to create an interactive environment for a user to input to commands and view the execution of these commands through both a graphical window and a text console. Users will also be able to use the GUI to easily access data such as created methods, variables, and previously used commands. The goal is to make the backend flexible by making it easy to add commands with new functionality, and to add new logical structures, such as while loops. The goal is to make the front end flexible by making it easy to implement new views with varying functionalities. The front end is completely closed off from the backend, and the logic of the execution of commands is completely closed off from the front end. The main interaction between the front end and the backend is the front end obtaining commands from the user, which it then passes on to the backend to execute. The front end and back end also communicate about information front end needs to display through observable lists.

In order to add a new command to the language, an new subclass of BasicCommand needs to be created with an overridden executeCommand method which obtains values from the commandList to obtain results. This command's description should be added to commandDescription.properties, and the command should also be added to the language's resource file.

In order to add a new component to front end, a new Window subclass should be created with whatever is necessary for the component. The name of the subclass should be added to windows.properties for the purposes of reflection. Also, if the subclass constructor contains parameters which aren't already accounted for in WindowViewer, WindowViewer needs to be modified to account for the new parameters in createTab(). However, with the current design, all of the possible useful parameters have been accounted for.

Many of the views required information from backend to be displayed for the benefit of the viewer. We debated how we wanted to provide information so that the displayed information would change as backend changed values. One design plan was to provide lists to front end and then update periodically. Another plan was to provide observable lists to front end and use listeners to ensure that displays update as information changes. Both of these plans work very similarly from a design point of view, although I prefer the second plan because it seems slightly more efficient. However, updating periodically could lead to a simpler, less convoluted design. For instance, I'm using listeners to update the turtle information displayed in one of the views. There's a complicated track of observables and listeners which leads to the display being updated. This code could have been more readable with a simple update method instead of keeping track of each and every turtle constantly. With both of these plans, if the lists being provided to the front end are clones, the back end should still remain encapsulated from the front end so that in order to change any information such as variable contents, the front end needs to execute a command using CommandConsole. We ended up implementing both of these design plans for different views because we didn't communicate as well as we should have to keep our methods consistent.

In order to resolve the ambiguity of what tell [ 100 ] would do, we decided that it would just create a new turtle with ID 100, rather than all the turtles up to 100.

The front end of the IDE was designed with several layers of borderpanes within one another so that their placements are less rigid. In the end, the placement of console, turtle display, and tool bar became permanent, so only the bottom left corner of the IDE became a "flexible" spot.
In order to allow flexibility in that specific corner, WindowViewer class was implemented, which allowed the user to add pre-defined window classes to it in the form of a stack. 

